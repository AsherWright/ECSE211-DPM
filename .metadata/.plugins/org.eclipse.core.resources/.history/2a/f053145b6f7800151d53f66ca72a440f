import lejos.hardware.Sound;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.robotics.SampleProvider;


public class Driver extends Thread {
	private static final int ROTATESPEED = 30;
	private static final int FORWARDSPEED = 50;
	
	private SampleProvider usSensor;
	private float[] usData;
	private int filterControl;
	private static int FILTER_OUT = 3;
	private float lastDistance;
	EV3LargeRegulatedMotor leftMotor;
	EV3LargeRegulatedMotor rightMotor;
	Odometer odo;
	Navigation navi;
	BlockDetector detector;
	/*
	 * constructor. We need the odometer (for position info), the detector (for block detection), and the US data
	 */
	public Driver(EV3LargeRegulatedMotor leftMotor, EV3LargeRegulatedMotor rightMotor, Odometer odo, BlockDetector detector, SampleProvider usSensor, float[] usData, Navigation navi){
		this.usData = usData;
		this.usSensor = usSensor;
		filterControl = 0;
		lastDistance = 100;
		this.leftMotor = leftMotor;
		this.rightMotor = rightMotor;
		this.odo = odo;
		this.navi = navi;
		this.detector= detector;
	}
	
	/*
	 * Finds the block on the field, grabs it, and returns it.
	 */
	public void run(){
		//begin spinning clockwise to scan for blocks
		leftMotor.setSpeed(ROTATESPEED);
		rightMotor.setSpeed(ROTATESPEED);
		leftMotor.forward();
		rightMotor.backward();
		while(true){
			double USDistance = getFilteredUSData();
			/*
			 * if we see a block
			 */
			if(USDistance < 5){
				leftMotor.stop(true);
				rightMotor.stop(true);
				break;
			}else if(USDistance <15){
				leftMotor.rotate(10, true);
				rightMotor.rotate(-convertAngle(Lab5.WHEEL_RADIUS, Lab5.TRACK, 3.0), true);
			
			}else if(USDistance < 120){
				leftMotor.setSpeed(FORWARDSPEED);
				rightMotor.setSpeed(FORWARDSPEED);
				leftMotor.forward();
				rightMotor.forward();
			}else if(USDistance > 120){
				leftMotor.setSpeed(ROTATESPEED);
				rightMotor.setSpeed(ROTATESPEED);
				leftMotor.forward();
				rightMotor.backward();
			}
			
		}
		if(detector.isReadingBlock()){
			Sound.buzz();
		}
		
	}
	
	private float getFilteredUSData() {
		usSensor.fetchSample(usData, 0);
		float distance = (int)(usData[0]*100.0);
		float result = 0;
		if (distance > 200){
			// true 255, therefore set distance to 255
			result = 200; //clips it at 50
		} else {
			// distance went below 255, therefore reset everything.
			filterControl = 0;
			result = distance;
		}
		//lastDistance = distance;
		return result;
	}
	//Conversion methods.
	private static int convertDistance(double radius, double distance) {
		return (int) ((180.0 * distance) / (Math.PI * radius));
	}
	private static int convertAngle(double radius, double width, double angle) {
		return convertDistance(radius, Math.PI * width * angle / 360.0);
	}
}
